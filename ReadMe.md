## LeetCode

### 一、stl+math综合
#### 预备知识：map、unordered_map、priority_queue、queue、set、stack、pair、list

#### 1.1 LeetCode533 孤独像素 II
1. 

#### 1.2 LeetCode060 第k个排列
1. vector 删除指定索引的元素
```c++
vector<int> nums;
auto it = begin(nums); // vector<int>::iterator it = begin(nums);
nums.erase(it + index);
```

#### 1.3 LeetCode347 前k个高频元素
1. 优先队列实现比较器
```c++
using Ele = pair<int, int>;  // 元素，出现次数

struct Cmp {   // 按照 Ele 第二个元素从大到小排序，最大堆/优先队列
    bool operator()(Ele &e1, Ele &e2) {
        return e1.second < e2.second;
    }
};
```



### 二、贪心算法
#### 预备知识
贪心法：遵循某种规律，不断贪心的选取当前最优策略的算法设计方法。

#### 2.1 LeetCode455 用更小的饼干满足更多的孩子
1. 贪心：某个孩子可以用更小的糖果满足，则没必要用更大糖果满足，因为可以保留更大的糖果满足需求因子更大的孩子

#### 2.2 LeetCode376 删除一些元素获取摆动序列
1. 贪心：当序列有一段连续的递增(或递减时)，为形成摇摆序列，我们只需要保留这些连续的递增(或递减时)的首尾元素，
   这样更可能使得尾部的后一个元素成为摇摆子序列的下一个元素。
2. 状态机

#### 2.3 LeetCode402 移除 k 个数字使新数字最小
1. 贪心：若去掉某一位数字，为使得新数字最小，尽可能让新数字优先最高位最小 + 
   从高位到低位遍历，如果当前数字(单调栈top)大于下一位数字，则把当前数字从栈中pop掉
2. 单调栈 

#### 2.4 LeetCode055 跳跃游戏
1. nums[] -> index[] -> 遍历 index[] 记录 maxIndex(贪心：在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择)
2. index[] 表示当前位置能跳的最远位置index

#### 2.5 LeetCode045 跳跃游戏 II (经典，再做几次)
1. 思考为了使得跳跃次数最少，什么时机跳最优？
2. 起始位置0，可跳到最远距离是 nums[0]，在索引 0~nums[0] 区间遍历，记录遍历过程中可达到的最远距离，
   索引位置j∈[0,nums[0]]，则跳到索引j处，最远距离 j+nums[j]。
3. 0~nums[0] 区间遍历结束意味着必须跳，此时跳跃次数 + 1。
4. 0~nums[0] 区间遍历结束时当前位置是上一轮的可达到的最远距离。

#### 2.6 LeetCode452 用最少数量的箭引爆气球
1. 贪心：对于某个气球，至少需要1只弓箭将其击穿，在这只气球被击穿同时，尽可能击穿其他更多的气球
2. 按照气球左端点排序，遍历气球数组，同时维护一个射击区间，尽可能射击更多气球，每射击一个新气球
   更新一次射击区间。如果新的气球没办法击穿，则新增一个弓箭手，维护一个射击区间。
3. 自定义 sort 函数里的 compare 函数对 vector<vector<int>> 进行排序

#### 2.7 Poj2431 最优加油方法 (经典，再做几次)
1. 贪心：(1) 在油用光的时候加油最合适 (2) 在油量最多的加油站加油最合适
2. 思路：(1) 设置一个最大堆，用来存储经过加油站的汽油量
        (2) 按照从起点至终点的方向，遍历各个加油站之间的距离
        (3) 每次需要走两个加油站之间的距离d，如果发现汽油不够走距离d时，从最大堆中取出一个油量添加，直到可以足够走距离d
        (4) 如果把最大堆的汽油都添加仍然不够进行距离d，则无法达到终点
        (5) 当前油量p减少d
        (6) 将当前加油站油量添加至最大堆
3. 优先队列/最大堆 priority_queue<int, vector<int>, less<int> >  等同于 priority_queue<int>
4. 最小堆/升序队列 priority_queue<int, vector<int>, greater<int>> 

#### 2.8 LeetCode763 划分字母区间 (再做几次)
1. 类似跳跃游戏，重点是起跳位置需跳到最远处进行更新

#### 2.9 LeetCode1167 链接棒材的最低费用
1. 贪心：为使得费用最低，每次都从所有棒材中选择最短的两根棒材进行链接
2. 最小堆/优先队列priority_queue<int, vector<int>, greater<int>> 

#### 2.10 LeetCode253 会议室 II (再做几次)
1. 贪心：会议排序，当新会议要开始时比较此会议开始时间和所有房间会议结束时间最小值(最早结束会议)，如果不冲突不需要安排新会议室

#### 2.11 LeetCode1094 拼车
1. 思路和会议室 II 同
2. 自定义优先队列的比较器 
```c++
struct PQCmp {
    // 按照结束位置在优先队列里排序，最小优先队列
    bool operator()(Trip &p1, Trip &p2) {
        return p1.first > p2.first;
    }
};
```

#### 2.12 LeetCode1055 形成字符串的最短路径
1. 

### 三、搜索(二维数组、无向图搜索)
#### 3.1 LeetCode200:岛屿数量：二维数组上连一起为一个岛
1. 二维数组上深度优先搜索模版题 二维数组记录访问过的点
2. 广搜模版题 搜索队列searchQueue 二维数组记录访问过的点 将带搜索的位置push进入到队列 
放入搜索队列意味着已经搜索过+准备搜索周围位置

#### 3.2 LeetCode127:单词接龙
1. 无向图广度优先搜索模版题  邻接表map<string,vector<string>>表示图 
    - 记录搜索过程步数  
    - 搜索队列queue<pair<顶点,步数>>
    - 集合set<string>记录搜索过的结点
    - 尽量使用 const 和 & 减少时间消耗
2. 广搜模版特点: (1) push 进入 searchQueue 时同时要 insert 进 visit
               (2) 从 searchQueue 取出要搜索结点后要从 searchQueue 里 pop 掉此结点                
               (3) 放入搜索队列可以多放点其他信息，比如 step
3. 广搜模版
```c++
void Bfs(map graph, set visit, T start, T target) {
    queue<pair<string, int>> searchQueue;
    searchQueue.push(make_pair(beginWord, 1));
    visit.insert(beginWord);

    while (!searchQueue.empty()) {
        string cur = searchQueue.front().first;
        int step = searchQueue.front().second;
        searchQueue.pop();

        // 此处取出当前搜索结点进行处理

        for (string &word: graph[cur]) {
            if (visit.find(word) != visit.end()) {
                continue;
            }

            searchQueue.push(make_pair(word, step + 1));
            visit.insert(word);
        }
    }
}
```               
    
#### 3.3 LeetCode126:单词接龙2(hard)
1. 记录所有路径的广搜
2. 邻接表表示图 起点到终点多条路径保存
    - 搜索队列使用 vector<Qitem> 替换 queue<pair<string,int>> 从而保存所有路径
    - Qitem 保存着前驱节点位置和步数信息，比 pair<string,int> 多了一个前驱结点在队列中的位置
    - 使用map<string, int> 替换集合记录搜索过的结点:记录达到m每个位置所需最小步数，存取不同前驱到达该位置情况
    - 使用变量 front 表示搜索队列的队列头，而不需要pop掉
    

#### 3.4 LeetCode407:接雨水 II(hard)
1. 带优先级的广度优先搜索 优先队列 未做

#### 3.5 LeetCode079:单词搜索
1. 二维数组上深度优先搜索 + 回溯算法
2. 核心，从 x,y 开始深搜时先保存当前结点，如果失败在回退。
board[x][y] = 0;是为了再次搜索这个位置肯定走不通，因为不等于目标word
```C++
char temp = board[x][y];
board[x][y] = 0;
...
... 以 x,y 为起点进行深搜
...
board[x][y] = temp;
return false;
```

#### 3.6 LeetCode994 腐烂的橘子
1. 二维数组上广度优先搜索  思路基本和 岛屿数量 一样
2. 特点是每次需要将队列里的所有节点一次性搜索完

#### 3.7 LeetCode695 岛屿的最大面积
1. 二维数组上深搜模版题
2. 广搜模版题
3. 用于练习搜索常用套路模版

#### 3.8 LeetCode1293:网格中的最短路径(hard)

#### 3.9 LeetCode815:公交路线
1. 无向图上的广度优先搜索，结点是 set<int>

### 四、二叉树与有向图(二叉树、有向图的搜索)
#### 预备知识
```c++
              1
             / \
            2   5
           / \   \
          3   4   6
```
1. 二叉树的深度遍历
    - 前序遍历: 1->2->3->4->5->6 当前结点->左子树->右子树
    - 中序遍历: 3->2->4->1->5->6 左子树->当前结点->右子树
    - 后序遍历: 3->4->2->6->5->1 左子树->右子树->当前结点
2. 二叉树的层次遍历 : 1->2->5->3->4->6

#### 4.1 LeetCode113 路径之和2
1. 记录路径的深度搜索模版题 前序遍历 
2. 记录路径 所以 需要 回溯算法
```c++
void Preorder(TreeNode *node, vector<int> &visit, vector<vector<int>> &path, int &sum, int &target) {
```

#### 4.2 LeetCode236:最近的公共祖先
1. 记录路径的深度搜索模版题 前序遍历 
2. 记录路径 所以 需要 回溯算法
3. finish 变量用于找到目标路径后不再寻找。
```c++
void Preorder(TreeNode *node, vector<TreeNode *> &visit, vector<TreeNode *> &path, 
    TreeNode *target, int &finish)
```

#### 4.3 LeetCode144:二叉树转链表(最经典前中后序)
1. 使用vector<Treenode *>保存所有结点
2. 原地转链表

#### 4.4 LeetCode199:侧面观察二叉树
1. 二叉树广搜 二叉树层次遍历 结点与层数绑定为pair压入队列

#### 4.5 LeetCode207:有向图判断环
1. 未做

#### 4.6 LeetCode332: 重新安排行程
1. 给定一个 n 个点 m 条边的图，要求从指定的顶点出发，经过所有的边恰好一次
（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小。
2. Hierholzer 算法用于在连通图中寻找欧拉路径

#### 4.6 LeetCode337:打家劫舍 III
1. 二叉树深搜 使用到layer

#### 4.7 LeetCode107：二叉树的层次遍历 II
1. 二叉树广搜 二叉树层次遍历 
2. reverse 函数逆序容器元素 reverse(path.begin(), path.end());

#### 4.8 LeetCode094：二叉树的中序遍历(迭代)
1. 中序遍历，迭代方法，非递归

#### 4.9 LeetCode617：合并二叉树
1. 中序遍历 递归

### 五、动态规划
#### 5.1 LeetCode070 爬楼梯
1. 动态规划 dp[i]表示爬到第i阶多少种不同的方法，用vector<int>类型表示
2. dp[i]=dp[i−1]+dp[i−2]

#### 5.2 LeetCode198 打家劫舍
1. 动态规划 dp[i]表示偷窃前i个房间能够偷窃到的最高金额，用vector<int>类型表示
2. dp[i] = max(nums[i]+dp[i-2], dp[i-1])

#### 5.3 LeetCode053 最大子序和
1. 动态规划 dp[i] 表示以 nums[i] 结尾的最大子序和
2. dp[i] = max(dp[i-1]+nums[i], nums[i])
3. 经典

#### 5.4 LeetCode322 零钱兑换：凑成总金额所需的最少的硬币个数 (经典在做几次)
1. 方法1：背包，动态规划 dp[i] 表示金额 i 的最少使用钞票的张数 
    - dp[i] = min(dp[i-c1], dp[i-c2], ..., dp[i-cn]) + 1 = min(dp[i-c1] + 1, dp[i-c2] + 1, ..., dp[i-cn] + 1)
    - c1, c2 ... cn 表示第 n 枚硬币的面值
2. 方法2：贪心
    - 想要总硬币数最少，肯定是优先用大面值硬币，所以对 coins 按从大到小排序
    - 先丢大硬币，再丢会超过总额时，就可以递归下一层丢的是稍小面值的硬币
    ```
    k = amount / coins[c_index] 计算最大能投几个
    amount - k * coins[c_index] 减去扔了 k 个硬币
    count + k 加 k 个硬币
    ```

#### 5.5 LeetCode120 三角形最小路径和
1. 动态规划 二维dp[i][j] 表示数组三角形第i行，第j列的最优解  
2. 从下到上递推
    - dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + nums[i][j]
    
#### 5.6 LeetCode300 最长上升子序列
1. 动态规划 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取 o(n2)
2. dp[i] = max[dp[j]] + 1, 其中0≤j<i且num[j]<num[i]

#### 5.7 LeetCode064 最小路径和
1. 动态规划 二维dp[i][j] 表示从 (0,0) 走到 (i,j) 位置时最小路径和
2. dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + nums[i][j]

#### 5.8 LeetCode174 地下城游戏
1. 动态规划 从右下到左上递推 dp[i][j] 表示从 (i,j) 位置到右下角至少需要多少血量，在行走过程中至少保持生命值为1
2. dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - nums[i][j])

#### 5.9 LeetCode337 打家劫舍 III
1. 动态规划 + 后序遍历
2. 核心思路
```C++
pair<int, int> 
// 第 1 个元素表示:打劫 root 时能够盗取的最高金额
// 第 2 个元素表示:不打劫 root 时能够盗取的最高金额 max(左儿子情况1, 左儿子情况2) + max(右儿子情况1, 右儿子情况2)。
```
   
#### 5.10 LeetCode085:最大矩形
1. 

#### 5.11 LeetCode221 最大正方形
1. 

#### 5.12 LeetCode005 最长回文子串
1. 

### 六、复杂数据结构:trie树(字典树/前缀树)+并查集+线段树(前4道经典题目)
#### Trie 树 (功能类似于 hash 表)
1. Trie 树数据结构
    - Trie 树的构造
    - Trie 树的前序遍历 
    - Trie 树获取全部单词
2. Trie 树整体功能
    - 将 word 插入 Trie 树
    - 搜索 Trie 树中是否有 word
    - 确认 Trie 树中是否有前缀为 prefix 的单词

#### Union Find 并查集
#### SegmentTree 线段树
1. 是平衡二叉搜索树，除了最后一层，其他都是满的二叉树
2. 线段树是完全二叉树，所以可以使用数组保存。如果跟结点索引为 i，则左子树跟结点索引 2i+1，右 2i+2
#### 6.1 LeetCode307 区域和检索 - 数组可修改
#### 6.2 LeetCode400 字典序的第 k 个小数字
#### 6.2 LeetCode820  单词的压缩编码
1. 


### 七、哈希表与字符串
#### 7.1 LeetCode409 最长回文串
1. 字符哈希 int charMap[128]

#### 7.2 LeetCode290 词语模式
1. 字符串哈希 map strMap<string, char>

#### 7.3 LeetCode049 同字符词语分组
1. 数组哈希
2. 熟练 map<string, vector<string>> 操作 (在做几次)

#### 7.4 LeetCode003 无重复字符的最长子串
1. 字符哈希：判断当前字符是否已经存在
2. 滑动窗口：左右两指针

#### 7.5 LeetCode187 重复的DNA序列
1. 字符串哈希 map strMap<string, int> 滑动窗口

#### 7.6 LeetCode076 最小窗口子串
1. 哈希维护窗口 (在做几次)
2. 窗口字符串哈希 键是字符 值是出现次数
3. 比较做指针在窗口哈希次数大于出现在字符串t时右移

### 八、二分搜索与二叉查找树
#### 预备知识
1. 二叉查找树与二叉树区别在于查找树如下性质：
    (1) 左子树不为空，左子树上所有结点的值都小于跟结点的值
    (2) 右子树不为空，右子树上所有结点的值都大于跟结点的值
    (3) 二叉查找树的中序遍历是从小到大的
2. 二叉查找树注意树的构造

#### 4.1 LeetCode035:插入位置
1. 二分查找

#### 4.2 LeetCode034:区间查找
1. 二分查找

#### 4.3 LeetCode033:旋转数组查找(未做)
1. 二分查找、搜索旋转数组

#### 4.4 LeetCode449:序列化和反序列化二叉搜索树
1. 二叉查找树前序遍历 
2. 整形转字符串 to_string 字符串转整形 stoi
3. 字符串拆分为整数 
4. 字符串与数字间处理
5. 二叉查找树插入结点

#### 4.5 LeetCode315:计算右侧小于当前元素的个数
1. 二叉查找树应用
2. 逆序数 二叉查找树中有多少元素小于当前插入元素 二叉查找树添加新成员左子树结点数量

#### 4.6 LeetCode538:把二叉搜索树转换为累加树
1. 反序中序遍历：若求中间节点的值必须要先遍历完右子节点，而若求左子节点的值必须要遍历完中间节点和右子节点。
因此，我们只需要进行一次反向中序遍历（即遍历顺序为右子树-->根节点-->左子树），
在遍历过程中需要将已经遍历的节点的值进行累加，然后再赋值给当前节点。


### 九、递归、分治
#### 5.1 LeetCode---:子集 II:无重复子集
1. 回溯深搜

#### 5.2 LeetCode---:组合数之和2
1. 回溯深搜

#### 5.3 LeetCode---:生成括号
1. 回溯深搜

#### 5.4 LeetCode---:N皇后
1. 递归设计

#### 5.5 LeetCode---:计算右侧小于当前元素的个数，逆序数
1. 分治 
2. 归并排序

#### 5.6 LeetCod394:字符串解码
1. 递归解法
2. 辅助栈方法见 (20.4)

#### 5.7 LeetCod404:左叶子之和
1. 二叉树的递归
2. 核心是记录当前node结点是否是上一结点的左结点

### 十、回溯
#### 10.1 Leetcode473:火柴拼正方形
1. 回溯算法
2. 关键是如何进行回溯
```c++
sides[j] += nums[i];    // nums 的第 i 根火柴放入 sides 的第 j 条边上，接着放入第 i + 1 根火柴
if (Backtrack( nums, sides, target, i + 1)) {
    return true;
}
sides[j] -= nums[i];    // nums 的第 i 根火柴放入 sides 的第 j 条边上，无法成功则撤回放入 j + 1 条边上
```

#### 10.2 LeetCode077: 组合
1. 常规回溯算法，easy

#### 10.3 LeetCode039: 组合总和
1. 常规回溯算法，easy

#### 10.4 LeetCode040: 组合总和2 (*)
1. 使用 set 方法，耗时

2. 如何让同一层级(指不同路径相同顺序位的结点一致)，不出现相同的元素
防止出现 [1,1,2,5,6,7,10] target = 8时出现两次 [1,2,5]
第 i 次和第 i-1 次值相同，且第 i-1 次没有被选择，则第 i 次应该也不选

#### 10.5 LeetCode040: 组合总和3
1. 常规回溯算法，easy

#### 10.6 LeetCode078:子集：返回数组所有可能子集 (*)
1. 数组所有可能的子集

#### 10.7 LeetCode047:子集：全排列 II (*)
1. 数组所有可能的子集
- 使用 set 方法，耗时
2. 如何满足「全排列不重复」？
要解决重复问题，我们只要设定一个规则，保证在填第 \textit{idx}idx 个数的时候重复数字只会被填入一次即可。
而在本题解中，我们选择对原数组排序，保证相同的数字都相邻，然后每次填入的数一定是这个数所在重复数集合中
「从左往右第一个未被填过的数字」，即如下的判断条件：
```c++
if (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1]) {
    continue;
}
```
此思路和 LeetCode040: 组合总和2 一样


### 十一、位运算
#### 11.1 LeetCode201
#### 11.2 LeetCode421
1. 字典树
2. 
#### 11.3 LeetCode260
#### 11.4 LeetCode338
#### 11.5 LeetCode318
#### 11.6 LeetCode078
1. 位运算解法

### 二十、方法：栈
#### 20.1 LeetCode739 每日温度
1. 单调栈

#### 20.2 LeetCode084 柱状图最大矩形
1. 单调栈

#### 20.3 LeetCode085 最大矩形

#### 20.4 LeetCod394:字符串解码
1. 辅助栈解法
3. 常见数学函数
```c++
###include <cmath>
pow(4,2); // 4的平方=16
sqrt(4); // 4的平方根=2
abs(-4);
```

### 二十一、方法：前缀和
#### 21.1 LeetCode974

#### 21.2 Leetcode560


### 二十二、方法：差分/公交车

#### 22.1 LeetCode1094 拼车
1. 

#### 22.2 LeetCode1109 航班预定统计
1. 


### 二十三、方法：滑动窗口
#### 23.1 LeetCode1208 尽可能使字符串相等
1. 一维数组上滑动窗口：窗口和小于等于开销，右移右指针，窗口和大于开销，右移左指针
2. 典型滑动窗口